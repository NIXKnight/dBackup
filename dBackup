#!/usr/bin/env bash

# +------------------------------------------------------------------------------------------+
# + FILE: dBackup                                                                            +
# +                                                                                          +
# + DESCRIPTION: dBackup (Data Backup) is a parameterized wrapper written in bash around     +
# +              different backup utilities for Linux/UNIX-like systems.                     +
# +                                                                                          +
# + AUTHOR: Saad Ali (https://github.com/NIXKnight)                                          +
# +                                                                                          +
# + LICENSE: MIT License (See LICENSE file)                                                  +
# +------------------------------------------------------------------------------------------+

# SCRIPT VERSION

VERSION="v1.0-dev"

# GLOBAL VARIABLES
TARKIVER=$(which tar) # Locate tar archiving utility.
TAR_ARCHIVES= # Empty variable - To be set by createTarArchive function.
DIRS= # Empty variable - To be set via -d or --directory argument. Target directories that
      # need to be backed up will be set here.
MBKP_DIR= # Empty variable - To be set via -D or --backup-directory argument. This will be the
          # master/destination backup directory which will contain backup directories based
          # on a date/time format.
KOMPRESOR= # Empty variable - To be set via -c or --conpression-format. This will help compress
           # a tar archive.
KOMPRES_FORMAT= # Empty variable - To be set via -c or --conpression-format. This will help
                # compress a tar archive.
DTSTRING="%Y%m%d" # Set a default date/time format. Used to set backup directory name. This can
                  # be overridden by providing a custom format via --strftime parameter.

# FUNCTIONS

# Function to show help
function showHelp {
  echo -e "dBackup $VERSION by Saad Ali (https://github.com/NIXKnight)"
  echo -e "This script is licensed under the terms of MIT License."
  echo -e "\nUSAGE: dBackup [OPTIONS]"
  echo -e "\nOPTIONS"
  echo -e "\n  The script supports the following options, which should be specified on the command line:"
  echo -e "\n    -h or --help"
  echo -e "      Print this help."
  echo -e "\n    -d or --directory [/path/to/target/directory]"
  echo -e "      Target directory to be included in a backup. Provide this parameter multiple times to backup multiple directories."
  echo -e "      Example: ./dBackup -d /opt/foo --directory /home/bar"
  echo -e "\n    -D or --backup-directory [/path/to/destination/directory]"
  echo -e "      Destination directory where backup is placed in a subdirectory named after the date of the backup."
  echo -e "      If the destination backup directory doesn't exist, the script will ask you wether to create it or not."
  echo -e "      Example: ./dBackup -d /opt/foo --directory /home/bar -D /backup"
  echo -e "\n    -c or --compression-format [gzip|bzip2]"
  echo -e "      The compression format to use. If this parameter is not provided, compression will not be performed."
  echo -e "      Example: ./dBackup -d /opt/foo --directory /home/bar -D /backup -c bzip2"
  echo -e "\n    --strftime [date format]"
  echo -e "      Change date format of backup directory name. By default the date format is %Y%m%d."
  echo -e "      Example: ./dBackup -d /opt/foo --directory /home/bar -D /backup -c bzip2 --strftime %d_%B_%Y"
}

# This function validates if a directory exists. If the directory exists,it checks if the DIRS
# variable is zero or not. If the variable has zero length, then set it to the provided
# directory. If the variable does not have zero length, add the directory to the variable.
# If the directory does not exist, then exit the script.
function validateAndSetTargetDirectory {
  if [ -d $1 ] ; then
    if [[ -z $DIRS ]] ; then
      DIRS="$1"
    else
      DIRS="$DIRS $1"
    fi
  else
    printf "Target directory $1 is not a valid directory!\nExiting...\n"
    exit 1
  fi
}

# This function validates if the mentioned master backup directory containing backups exists.
# If the said directory exists then it sets the variable MBKP_DIR. If the directory doesn't
# exist, the script will ask the user whether to create the directory or not. based on user
# input, either the directory will be created and the variable will be set or the script
# will exit.
function validateAndSetMasterBackupDirectory {
  if [ -d $1 ] ; then
    MBKP_DIR=$1
  else
    read -p "Specified backup directory $1 doesn't exist. Do you want to create $1 ? [y/n]: " RESPONSE
    local INPUT=$(echo $RESPONSE | tr '[:upper:]' '[:lower:]')
    case $INPUT in
      y|yes)
        mkdir $1
        local MKDIR_STATUS=$(echo $?)
        if [ $MKDIR_STATUS -eq 0 ] ; then
          printf "Directory $1 created successfully.\n" | tee -a $LOG_FILE
          MBKP_DIR=$1
        else
          printf "Directory $1 could not be created!\nExiting...\n" | tee -a $LOG_FILE
          exit 1
        fi
        ;;
      n|no)
        printf "Exiting...\n"
        exit 0
        ;;
      *)
        printf "Cannot recognize input!\nExiting...\n"
        exit 1
    esac
  fi
}

# This function validates compression format arguments -c or --compression-format and sets
# along with its binary. If the binary is not found, it will exit the script.
function validateAndSetCompressionFormat {
  local FORMAT=$(echo $1 | tr '[:upper:]' '[:lower:]')
  case $FORMAT in
    bz2|bzip2)
      KOMPRES_FORMAT="bz2"
      KOMPRESOR=$(which pbzip2)
      if [ -z $KOMPRESOR ] ; then
        printf "pbzip2 binary not found on this system!\nInstall pbzip2 and then run the script again.\nExiting...\n"
        exit 1
      fi
      ;;
    gz|gzip)
      KOMPRES_FORMAT="gz"
      KOMPRESOR=$(which pigz)
      if [ -z $KOMPRESOR ] ; then
        printf "pigz binary not found on this system!\nInstall pigz and then run the script again.\nExiting...\n"
        exit 1
      fi
      ;;
    *)
      printf "Supported compression formats are bzip2 (bz2) or gzip (gz)!\nExiting...\n"
      exit 1
      ;;
  esac
}

# This function will create a tar archive of the specified directory or directories and put
# them in BKP_DIR and add resulting files along with their paths to TAR_ARCHIVES for
# further compress them to either gzip or bzip2 (if selected)
function createTarArchive {
  local TARGET=$(basename $1)
  local PATH_TO_TARGET=$(dirname $1)
  local ARCHIVE="$2/$TARGET.tar"
  printf "Creating TAR archive for $1 --> $ARCHIVE\n" | tee -a $LOG_FILE
  $TARKIVER -cf $ARCHIVE -C $PATH_TO_TARGET $TARGET >> $LOG_FILE 2>&1
  local TARKIVER_STATUS=$(echo $?)
  if [ $TARKIVER_STATUS -eq 0 ] ; then
    printf "TAR archive $ARCHIVE for $1 created successfully.\n" | tee -a $LOG_FILE
  else
    printf "Creation of TAR archive $ARCHIVE failed!\nExiting...\n" | tee -a $LOG_FILE
    exit 1
  fi
  if [[ -z $TAR_ARCHIVES ]] ; then
    TAR_ARCHIVES="$ARCHIVE"
  else
    TAR_ARCHIVES="$TAR_ARCHIVES $ARCHIVE"
  fi
}

# This function checks if the input variable $1 is not empty then for every directory in
# $1 create a tar archive in $2.
function backupDirectories {
  if [ ! -z "$1" ] ; then
    printf "Executing directory archival routine...\n"  | tee -a $LOG_FILE
    for DIR in $1 ; do
      createTarArchive $DIR $2
    done
  fi
}

# This function compresses a file to the selected format.
function compressFile {
  local FILE="$1.$KOMPRES_FORMAT"
  local BINARY=$(basename $KOMPRESOR)
  printf "Using $BINARY with max compression $1 --> $FILE\n"  | tee -a $LOG_FILE
  $KOMPRESOR -9 $1
  local KOMPRESSION_STATUS=$(echo $?)
  if [ $KOMPRESSION_STATUS -eq 0 ] ; then
    printf "$1 --> $FILE compression successful.\n"  | tee -a $LOG_FILE
  else
    printf "Error during compression $1 --> $FILE !\nExiting...\n"  | tee -a $LOG_FILE
    exit 1
  fi
}

# This function checks if variable $KOMPRESOR and $KOMPRES_FORMAT are not empty then for
# every file in $1 compress the file.
function compressBackups {
  if [[ ! -z $KOMPRESOR && ! -z $KOMPRES_FORMAT ]] ; then
    printf "Executing file compression routine...\n"  | tee -a $LOG_FILE
    for FILE in $1 ; do
      compressFile $FILE
    done
  else
    printf "Compression format not provided.\nSkipping compression routine...\n"  | tee -a $LOG_FILE
  fi
}

# PARAMETERS TO BE USED BY THE SCRIPT

SHORT_OPTS="hd:,D:,c:"
LONG_OPTS="help,directory:,backup-directory:,strftime:,compression-format:"
OPTS=$(getopt --shell bash --options $SHORT_OPTS --longoptions $LONG_OPTS -- $@)

# Show help if no or invalid parameter is provided

if [ $? != 0 ] ; then
  echo -e "Use -h or --help to see options.\nExiting..."
  exit 1
elif [[ $NUMARGS -eq 0 ]] ; then
  showHelp
  exit 1
fi

eval set -- "$OPTS"

# PARAMETER PARSING START

while true ; do
  case "$1" in
    -h|--help)
      showHelp
      exit 0
      ;;
    -d|--directory) # This parameter is used to set the target directory or directories that
                    # will be included in a backup.
      validateAndSetTargetDirectory $2
      shift 2
      ;;
    -D|--backup-directory) # This parameter is used to set the master/destination backup
                           # directory.
      validateAndSetMasterBackupDirectory $2
      shift 2
      ;;
    -c|--compression-format) # This parameter is used to set a compression format to either
                             # gzip or bzip2.
      validateAndSetCompressionFormat $2
      shift 2
      ;;
    --strftime) # This parameter is used to set a custom date/time format which will be used to
                # set backup directory name.
      shift 2
      ;;
    --)
      shift
      break
      ;;
    *)
      showHelp
      exit 1
      ;;
  esac
done

# PARAMETER PARSING END
